(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{352:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return a})),r.d(t,"metadata",(function(){return c})),r.d(t,"toc",(function(){return u})),r.d(t,"default",(function(){return f}));var n=r(3),o=r(7),i=(r(0),r(411)),s=["components"],a={title:"rucio-conveyor-throttler"},c={unversionedId:"bin/rucio-conveyor-throttler",id:"bin/rucio-conveyor-throttler",isDocsHomePage:!1,title:"rucio-conveyor-throttler",description:"`",source:"@site/../docs/bin/rucio-conveyor-throttler.md",sourceDirName:"bin",slug:"/bin/rucio-conveyor-throttler",permalink:"/documentation/bin/rucio-conveyor-throttler",editUrl:"https://github.com/rucio/documentation/tree/main/docs/../docs/bin/rucio-conveyor-throttler.md",version:"current",frontMatter:{title:"rucio-conveyor-throttler"},sidebar:"docs",previous:{title:"rucio-conveyor-submitter",permalink:"/documentation/bin/rucio-conveyor-submitter"},next:{title:"rucio-dark-reaper",permalink:"/documentation/bin/rucio-dark-reaper"}},u=[],l={toc:u};function f(e){var t=e.components,r=Object(o.a)(e,s);return Object(i.b)("wrapper",Object(n.a)({},l,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"usage: rucio-conveyor-throttler [-h] [--run-once] [--sleep-time SLEEP_TIME]\n\nThe Conveyor-Throttler daemon is responsible for managing the internal queue\nof transfer requests. Depending on transfer limits of current and waiting\ntransfers, it decides whether a transfer should be put in the queue or not.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --run-once            One iteration only\n  --sleep-time SLEEP_TIME\n                        Seconds to sleep if few requests\n\nIn this example, the transfer limit will be one transfer which means that\nthere should be only one active transfer at the time. There will be two\nwaiting transfer requests and no current active transfer. After running the\ndaemon, there will be one transfer in the queue which can then be started.\nSetup the transfer limit:: $ python from rucio.core.rse import\nset_rse_transfer_limits set_rse_transfer_limits('MOCK2', 'User Subscriptions',\nmax_transfers=1) $ rucio-admin config set --section throttler --option 'User\nSubscriptions,MOCK2' --value 1 If Rucio is running in multi-VO mode, then the\nRSE ID should be used in place of its name when setting the config:: $ rucio-\nadmin rse info MOCK2 Settings: ========= ... Attributes: =========== ...\nProtocols: ========== ... Usage: ====== ... rse_id:\n9c54c73cbd534450b2202a576f809f1f $ rucio-admin config set --section throttler\n--option 'User Subscriptions,9c54c73cbd534450b2202a576f809f1f' --value 1\nUpload two files and create replication rules to the same RSE:: $ rucio upload\n--scope mock --rse MOCK --name file1 filename.txt $ rucio add-rule mock:file 1\nMOCK2 $ rucio upload --scope mock --rse MOCK --name file2 filename.txt $ rucio\nadd-rule mock:file2 1 MOCK2 Check transfer requests:: $ python from\nrucio.db.sqla import session,models [request.to_dict() for request in\nsession.get_session().query(models.Request).all()] # [{'state': WAITING, ...},\n{'state': WAITING, ...} Two transfer requests with the state 'WAITING' got\ncreated. Run the daemon:: $ rucio-conveyor-throttler --run-once Check transfer\nrequests:: $ python from rucio.db.sqla import session,models\n[request.to_dict() for request in\nsession.get_session().query(models.Request).all()] # [{'state': WAITING, ...},\n{'state': QUEUED, ...} Finally one of the transfer requests got put in the\nqueue and can be picked up by the Conyevor-Submitter daemon to submit the\ntransfer job to the transfertool. The other request will have to wait until\none of the queued requests is done or until the transfer limit changes.\n")))}f.isMDXComponent=!0},411:function(e,t,r){"use strict";r.d(t,"a",(function(){return f})),r.d(t,"b",(function(){return d}));var n=r(0),o=r.n(n);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var u=o.a.createContext({}),l=function(e){var t=o.a.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},f=function(e){var t=l(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),f=l(r),m=n,d=f["".concat(s,".").concat(m)]||f[m]||p[m]||i;return r?o.a.createElement(d,a(a({ref:t},u),{},{components:r})):o.a.createElement(d,a({ref:t},u))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,s=new Array(i);s[0]=m;var a={};for(var c in t)hasOwnProperty.call(t,c)&&(a[c]=t[c]);a.originalType=e,a.mdxType="string"==typeof e?e:n,s[1]=a;for(var u=2;u<i;u++)s[u]=r[u];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);