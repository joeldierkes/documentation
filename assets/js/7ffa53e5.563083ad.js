(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{234:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return b})),n.d(t,"metadata",(function(){return a})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return s}));var o=n(3),l=n(7),r=(n(0),n(411)),i=["components"],b={title:"FileDownloadState"},a={unversionedId:"client_api/downloadclient",id:"client_api/downloadclient",isDocsHomePage:!1,title:"FileDownloadState",description:"\\\\init\\\\",source:"@site/../docs/client_api/downloadclient.md",sourceDirName:"client_api",slug:"/client_api/downloadclient",permalink:"/documentation/client_api/downloadclient",editUrl:"https://github.com/rucio/documentation/tree/main/docs/../docs/client_api/downloadclient.md",version:"current",frontMatter:{title:"FileDownloadState"},sidebar:"docs",previous:{title:"DiracClient",permalink:"/documentation/client_api/diracclient"},next:{title:"ExportClient",permalink:"/documentation/client_api/exportclient"}},c=[{value:"__init__",id:"__init__",children:[]},{value:"is_useable",id:"is_useable",children:[]},{value:"try_extraction",id:"try_extraction",children:[]},{value:"__init__",id:"__init__-1",children:[]},{value:"download_pfns",id:"download_pfns",children:[]},{value:"download_dids",id:"download_dids",children:[]},{value:"download_from_metalink_file",id:"download_from_metalink_file",children:[]},{value:"_download_multithreaded",id:"_download_multithreaded",children:[]},{value:"_download_worker",id:"_download_worker",children:[]},{value:"_compute_actual_transfer_timeout",id:"_compute_actual_transfer_timeout",children:[]},{value:"_download_item",id:"_download_item",children:[]},{value:"download_aria2c",id:"download_aria2c",children:[]},{value:"_start_aria2c_rpc",id:"_start_aria2c_rpc",children:[]},{value:"_download_items_aria2c",id:"_download_items_aria2c",children:[]},{value:"_resolve_one_item_dids",id:"_resolve_one_item_dids",children:[]},{value:"_resolve_and_merge_input_items",id:"_resolve_and_merge_input_items",children:[]},{value:"_options_from_input_items",id:"_options_from_input_items",children:[]},{value:"_prepare_items_for_download",id:"_prepare_items_for_download",children:[]},{value:"_split_did_str",id:"_split_did_str",children:[]},{value:"_prepare_dest_dir",id:"_prepare_dest_dir",children:[]},{value:"_check_output",id:"_check_output",children:[]},{value:"_send_trace",id:"_send_trace",children:[]},{value:"preferred_impl",id:"preferred_impl",children:[]},{value:"_verify_checksum",id:"_verify_checksum",children:[]}],d={toc:c};function s(e){var t=e.components,n=Object(l.a)(e,i);return Object(r.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"__init__"},"_","_","init","_","_"),Object(r.b)("p",null,"Initialises a extraction tool object"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"program_name"),": the name of the archive extraction program, e.g., unzip"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"useability_check_args"),": the arguments of the extraction program to test if its installed, e.g., --version"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"extract_args"),": the arguments that will be passed to the program for extraction"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"logger"),": optional decorated logging.log object that can be passed from the calling daemon or client."))))),Object(r.b)("h2",{id:"is_useable"},"is","_","useable"),Object(r.b)("p",null,"Checks if the extraction tool is installed and usable"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  True if it is usable otherwise False"))))),Object(r.b)("h2",{id:"try_extraction"},"try","_","extraction"),Object(r.b)("p",null,"Calls the extraction program to extract a file from an archive"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"archive_file_path"),": path to the archive"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"file_to_extract"),": file name to extract from the archive"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"dest_dir_path"),": destination directory where the extracted file will be stored"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  True on success otherwise False"))))),Object(r.b)("h2",{id:"__init__-1"},"_","_","init","_","_"),Object(r.b)("p",null,"Initialises the basic settings for an DownloadClient object"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"client"),": Optional: rucio.client.client.Client object. If None, a new object will be created."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"external_traces"),": Optional: reference to a list where traces can be added"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"logger"),": Optional: logging.Logger object. If None, default logger will be used."))))),Object(r.b)("h2",{id:"download_pfns"},"download","_","pfns"),Object(r.b)("p",null,"Download items with a given PFN. This function can only download files, no datasets."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"items"),": List of dictionaries. Each dictionary describing a file to download. Keys:\npfn                            - PFN string of this file\ndid                            - DID string of this file (e.g. 'scope:file.name'). Wildcards are not allowed\nrse                            - rse name (e.g. 'CERN-PROD_DATADISK'). RSE Expressions are not allowed\nbase_dir                       - Optional: Base directory where the downloaded files will be stored. (Default: '.')\nno_subdir                      - Optional: If true, files are written directly into base_dir. (Default: False)\nadler32                        - Optional: The adler32 checmsum to compare the downloaded files adler32 checksum with\nmd5                            - Optional: The md5 checksum to compare the downloaded files md5 checksum with\ntransfer_timeout               - Optional: Timeout time for the download protocols. (Default: None)\ncheck_local_with_filesize_only - Optional: If true, already downloaded files will not be validated by checksum."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"num_threads"),": Suggestion of number of threads to use for the download. It will be lowered if it's too high."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deactivate_file_download_exceptions"),": Boolean, if file download exceptions shouldn't be raised"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if one of the input items is in the wrong format"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NoFilesDownloaded"),": if no files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NotAllFilesDownloaded"),": if not all files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException"),": if something unexpected went wrong during the download"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a list of dictionaries with an entry for each file, containing the input options, the did, and the clientState\nclientState can be one of the following: ALREADY_DONE, DONE, FILE_NOT_FOUND, FAIL_VALIDATE, FAILED"))))),Object(r.b)("h2",{id:"download_dids"},"download","_","dids"),Object(r.b)("p",null,"Download items with given DIDs. This function can also download datasets and wildcarded DIDs."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"items"),": List of dictionaries. Each dictionary describing an item to download. Keys:\ndid                            - DID string of this file (e.g. 'scope:file.name')\nfilters                        - Filter to select DIDs for download. Optional if DID is given\nrse                            - Optional: rse name (e.g. 'CERN-PROD_DATADISK') or rse expression from where to download\nimpl                           - Optional: name of the protocol implementation to be used to download this item.\nno_resolve_archives            - Optional: bool indicating whether archives should not be considered for download (Default: False)\nresolve_archives               - Deprecated: Use no_resolve_archives instead\nforce_scheme                   - Optional: force a specific scheme to download this item. (Default: None)\nbase_dir                       - Optional: base directory where the downloaded files will be stored. (Default: '.')\nno_subdir                      - Optional: If true, files are written directly into base_dir. (Default: False)\nnrandom                        - Optional: if the DID addresses a dataset, nrandom files will be randomly choosen for download from the dataset\nignore_checksum                - Optional: If true, skips the checksum validation between the downloaded file and the rucio catalouge. (Default: False)\ntransfer_timeout               - Optional: Timeout time for the download protocols. (Default: None)\ntransfer_speed_timeout         - Optional: Minimum allowed transfer speed (in KBps). Ignored if transfer_timeout set. Otherwise, used to compute default timeout (Default: 500)\ncheck_local_with_filesize_only - Optional: If true, already downloaded files will not be validated by checksum."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"num_threads"),": Suggestion of number of threads to use for the download. It will be lowered if it's too high."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deactivate_file_download_exceptions"),": Boolean, if file download exceptions shouldn't be raised"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sort"),": Select best replica by replica sorting algorithm. Available algorithms:\n",Object(r.b)("inlineCode",{parentName:"p"},"geoip"),"       - based on src/dst IP topographical distance\n",Object(r.b)("inlineCode",{parentName:"p"},"closeness"),"   - based on src/dst closeness\n",Object(r.b)("inlineCode",{parentName:"p"},"dynamic"),"     - Rucio Dynamic Smart Sort (tm)"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if one of the input items is in the wrong format"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NoFilesDownloaded"),": if no files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NotAllFilesDownloaded"),": if not all files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException"),": if something unexpected went wrong during the download"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a list of dictionaries with an entry for each file, containing the input options, the did, and the clientState"))))),Object(r.b)("h2",{id:"download_from_metalink_file"},"download","_","from","_","metalink","_","file"),Object(r.b)("p",null,"Download items using a given metalink file."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"item"),": dictionary describing an item to download. Keys:\nbase_dir                       - Optional: base directory where the downloaded files will be stored. (Default: '.')\nno_subdir                      - Optional: If true, files are written directly into base_dir. (Default: False)\nignore_checksum                - Optional: If true, skips the checksum validation between the downloaded file and the rucio catalouge. (Default: False)\ntransfer_timeout               - Optional: Timeout time for the download protocols. (Default: None)\ncheck_local_with_filesize_only - Optional: If true, already downloaded files will not be validated by checksum."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"num_threads"),": Suggestion of number of threads to use for the download. It will be lowered if it's too high."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deactivate_file_download_exceptions"),": Boolean, if file download exceptions shouldn't be raised"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if one of the input items is in the wrong format"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NoFilesDownloaded"),": if no files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NotAllFilesDownloaded"),": if not all files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException"),": if something unexpected went wrong during the download"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a list of dictionaries with an entry for each file, containing the input options, the did, and the clientState"))))),Object(r.b)("h2",{id:"_download_multithreaded"},"_","download","_","multithreaded"),Object(r.b)("p",null,"Starts an appropriate number of threads to download items from the input list."),Object(r.b)("p",null,"(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"input_items"),": list containing the input items to download"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"num_threads"),": suggestion of how many threads should be started"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  list with output items as dictionaries"))))),Object(r.b)("h2",{id:"_download_worker"},"_","download","_","worker"),Object(r.b)("p",null,"This function runs as long as there are items in the input queue,"),Object(r.b)("p",null,"downloads them and stores the output in the output queue.\n(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"input_queue"),": queue containing the input items to download"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"output_queue"),": queue where the output items will be stored"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"log_prefix"),": string that will be put at the beginning of every log message"))))),Object(r.b)("h2",{id:"_compute_actual_transfer_timeout"},"_","compute","_","actual","_","transfer","_","timeout"),Object(r.b)("p",null,"Merge the two options related to timeout into the value which will be used for protocol download."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"item"),": dictionary that describes the item to download"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  timeout in seconds"))))),Object(r.b)("h2",{id:"_download_item"},"_","download","_","item"),Object(r.b)("p",null,"Downloads the given item and sends traces for success/failure."),Object(r.b)("p",null,"(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"item"),": dictionary that describes the item to download"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace"),": dictionary representing a pattern of trace that will be send"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"traces_copy_out"),": reference to an external list, where the traces should be uploaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"log_prefix"),": string that will be put at the beginning of every log message"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  dictionary with all attributes from the input item and a clientState attribute"))))),Object(r.b)("h2",{id:"download_aria2c"},"download","_","aria2c"),Object(r.b)("p",null,"Uses aria2c to download the items with given DIDs. This function can also download datasets and wildcarded DIDs."),Object(r.b)("p",null,"It only can download files that are available via https/davs.\nAria2c needs to be installed and X509_USER_PROXY needs to be set!"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"items"),": List of dictionaries. Each dictionary describing an item to download. Keys:\ndid                            - DID string of this file (e.g. 'scope:file.name'). Wildcards are not allowed\nrse                            - Optional: rse name (e.g. 'CERN-PROD_DATADISK') or rse expression from where to download\nbase_dir                       - Optional: base directory where the downloaded files will be stored. (Default: '.')\nno_subdir                      - Optional: If true, files are written directly into base_dir. (Default: False)\nnrandom                        - Optional: if the DID addresses a dataset, nrandom files will be randomly choosen for download from the dataset\nignore_checksum                - Optional: If true, skips the checksum validation between the downloaded file and the rucio catalouge. (Default: False)\ncheck_local_with_filesize_only - Optional: If true, already downloaded files will not be validated by checksum."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"filters"),": dictionary containing filter options"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deactivate_file_download_exceptions"),": Boolean, if file download exceptions shouldn't be raised"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sort"),": Select best replica by replica sorting algorithm. Available algorithms:\n",Object(r.b)("inlineCode",{parentName:"p"},"geoip"),"       - based on src/dst IP topographical distance\n",Object(r.b)("inlineCode",{parentName:"p"},"closeness"),"   - based on src/dst closeness\n",Object(r.b)("inlineCode",{parentName:"p"},"dynamic"),"     - Rucio Dynamic Smart Sort (tm)"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if one of the input items is in the wrong format"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NoFilesDownloaded"),": if no files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NotAllFilesDownloaded"),": if not all files could be downloaded"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException"),": if something went wrong during the download (e.g. aria2c could not be started)"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a list of dictionaries with an entry for each file, containing the input options, the did, and the clientState"))))),Object(r.b)("h2",{id:"_start_aria2c_rpc"},"_","start","_","aria2c","_","rpc"),Object(r.b)("p",null,"Starts aria2c in RPC mode as a subprocess. Also creates"),Object(r.b)("p",null,"the RPC proxy instance.\n(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"rpc_secret"),": the secret for the RPC proxy"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException"),": if the process or the proxy could not be created"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a tupel with the process and the rpc proxy objects"))))),Object(r.b)("h2",{id:"_download_items_aria2c"},"_","download","_","items","_","aria2c"),Object(r.b)("p",null,"Uses aria2c to download the given items. Aria2c needs to be started"),Object(r.b)("p",null,"as RPC background process first and a RPC proxy is needed.\n(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"items"),": list of dictionaries containing one dict for each file to download"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"aria_rcp"),": RPCProxy to the aria2c process"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"rpc_auth"),": the rpc authentication token"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace_custom_fields"),": Custom key value pairs to send with the traces"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a list of dictionaries with an entry for each file, containing the input options, the did, and the clientState"))))),Object(r.b)("h2",{id:"_resolve_one_item_dids"},"_","resolve","_","one","_","item","_","dids"),Object(r.b)("p",null,"Resolve scopes or wildcard DIDs to lists of full did names:"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"item"),": One input item"))))),Object(r.b)("h2",{id:"_resolve_and_merge_input_items"},"_","resolve","_","and","_","merge","_","input","_","items"),Object(r.b)("p",null,"This function takes the input items given to download_dids etc."),Object(r.b)("p",null,"and resolves the sources."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"It first performs a list_dids call to dereference any wildcards and\nretrieve DID stats (size, length, type)."),Object(r.b)("li",{parentName:"ul"},"Next, input items are grouped together by common list_replicas options.\nFor each group, a single list_replicas call is performed."),Object(r.b)("li",{parentName:"ul"},"The resolved File DIDs with sources are finally mapped back to initial\ninput items to be able to correctly retrieve download options\n(timeout, destination directories, etc)")),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"input_items"),": List of dictionaries. Each dictionary describing an input item"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if one of the input items is in the wrong format"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  a tuple:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"a dictionary that maps the dereferenced(w/o wildcards) input DIDs to a list of input items"),Object(r.b)("li",{parentName:"ul"},"and a list with a dictionary for each file DID which has to be downloaded")))))),Object(r.b)("h2",{id:"_options_from_input_items"},"_","options","_","from","_","input","_","items"),Object(r.b)("p",null,"Best-effort generation of download options from multiple input items which resolve to the same file DID."),Object(r.b)("p",null,"This is done to download each file DID only once, even if it is requested multiple times via overlapping\ndatasets and/or wildcard resolutions in distinct input items."),Object(r.b)("p",null,"Some options can be easily merged. For example: multiple base_dir are all appended to a list. As a result,\nthe file is downloaded once and copied to all desired destinations.\nOther options are not necessarily compatible. For example, two items requesting two different values for\ndownload timeout. We make our best to merge the options in such cases."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null)),Object(r.b)("h2",{id:"_prepare_items_for_download"},"_","prepare","_","items","_","for","_","download"),Object(r.b)("p",null,"Optimises the amount of files to download"),Object(r.b)("p",null,"(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"did_to_input_items"),": dictionary that maps resolved input DIDs to input items"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"file_items"),": list of dictionaries. Each dictionary describes a File DID to download"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if the given input is not valid or incomplete"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  list of dictionaries. Each dictionary describes an element to download"))))),Object(r.b)("h2",{id:"_split_did_str"},"_","split","_","did","_","str"),Object(r.b)("p",null,"Splits a given DID string (e.g. 'scope1:name.file') into its scope and name part"),Object(r.b)("p",null,"(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"did_str"),": the DID string that will be splitted"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"InputValidationError"),": if the given DID string is not valid"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  the scope- and name part of the given DID"))))),Object(r.b)("h2",{id:"_prepare_dest_dir"},"_","prepare","_","dest","_","dir"),Object(r.b)("p",null,"Builds the final destination path for a file and creates the"),Object(r.b)("p",null,"destination directory if it's not existent.\n(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"base_dir"),": base directory part"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"dest_dir_name"),": name of the destination directory"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"no_subdir"),": if no subdirectory should be created"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  the absolut path of the destination directory"))))),Object(r.b)("h2",{id:"_check_output"},"_","check","_","output"),Object(r.b)("p",null,"Checks if all files were successfully downloaded"),Object(r.b)("p",null,"(This function is meant to be used as class internal only)"),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"output_items"),": list of dictionaries describing the downloaded files"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deactivate_file_download_exceptions"),": Boolean, if file download exceptions shouldn't be raised"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NoFilesDownloaded"),": "),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"NotAllFilesDownloaded"),": "))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Returns"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,"  output_items list"))))),Object(r.b)("h2",{id:"_send_trace"},"_","send","_","trace"),Object(r.b)("p",null,"Checks if sending trace is allowed and send the trace."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"trace"),": the trace"))))),Object(r.b)("h2",{id:"preferred_impl"},"preferred","_","impl"),Object(r.b)("p",null,"Finds the optimum protocol impl preferred by the client and"),Object(r.b)("p",null,"supported by the remote RSE."),Object(r.b)("table",{style:{border:"none"}},Object(r.b)("tbody",null,Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Arguments"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"sources"),": List of sources for a given DID"))),Object(r.b)("tr",{style:{border:"none"}},Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Raises"),":")),Object(r.b)("td",{style:{border:"none",backgroundColor:"white",verticalAlign:"top"}},Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"RucioException(msg)"),": general exception with msg for more details."))))),Object(r.b)("h2",{id:"_verify_checksum"},"_","verify","_","checksum"))}s.isMDXComponent=!0},411:function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return O}));var o=n(0),l=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function b(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),d=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):b(b({},t),e)),n},s=function(e){var t=d(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},u=l.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,c=a(e,["components","mdxType","originalType","parentName"]),s=d(n),u=o,O=s["".concat(i,".").concat(u)]||s[u]||p[u]||r;return n?l.a.createElement(O,b(b({ref:t},c),{},{components:n})):l.a.createElement(O,b({ref:t},c))}));function O(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var b={};for(var a in t)hasOwnProperty.call(t,a)&&(b[a]=t[a]);b.originalType=e,b.mdxType="string"==typeof e?e:o,i[1]=b;for(var c=2;c<r;c++)i[c]=n[c];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);